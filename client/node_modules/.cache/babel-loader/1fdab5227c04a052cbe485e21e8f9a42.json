{"ast":null,"code":"'use strict';\n\nconst dns = require('dns'),\n      net = require('net'),\n      logger = require('./logger');\n\nconst ninvoke = (module, fn, ...args) => new Promise((resolve, reject) => {\n  module[fn](...args, (err, res) => {\n    if (err) return reject(err);\n    resolve(res);\n  });\n});\n/**\n * @see http://www.serversmtp.com/en/smtp-error\n * @param  {String} smtpReply A response from the SMTP server.\n * @return {Bool}             True if the error is recognized as a mailbox\n *                            missing error.\n */\n\n\nconst isInvalidMailboxError = smtpReply => {\n  if (smtpReply && /^(510|511|513|550|551|553)/.test(smtpReply) && !/(junk|spam|openspf|spoofing|host|rbl.+blocked)/ig.test(smtpReply)) return true;\n  return false;\n};\n/**\n * @see https://www.ietf.org/mail-archive/web/ietf-smtp/current/msg06344.html\n * @param  {String}  smtpReply A message from the SMTP server.\n * @return {Boolean}           True if this is a multiline greet.\n */\n\n\nconst isMultilineGreet = smtpReply => {\n  return smtpReply && /^(250|220)-/.test(smtpReply);\n};\n\nclass EmailValidator {\n  constructor(options = {}) {\n    this.options = Object.assign({\n      timeout: 10000,\n      verifyDomain: true,\n      verifyMailbox: true\n    }, options);\n    this.log = options.logger || logger;\n  }\n\n  async verify(address) {\n    const result = {\n      wellFormed: false,\n      validDomain: null,\n      validMailbox: null\n    };\n    let local;\n    let domain;\n    let mxRecords;\n\n    try {\n      [local, domain] = EmailValidator.extractAddressParts(address);\n    } catch (err) {\n      this.log.debug('Failed on wellFormed check', err);\n      return result;\n    }\n\n    result.wellFormed = true; // save a DNS call\n\n    if (!this.options.verifyDomain && !this.options.verifyMailbox) return result;\n\n    try {\n      mxRecords = await EmailValidator.resolveMxRecords(domain);\n      this.log.debug('Found MX records', mxRecords);\n    } catch (err) {\n      this.log.debug('Failed to resolve MX records', err);\n      mxRecords = [];\n    }\n\n    if (this.options.verifyDomain) {\n      result.validDomain = mxRecords && mxRecords.length > 0;\n    }\n\n    if (this.options.verifyMailbox) {\n      result.validMailbox = await EmailValidator.verifyMailbox(local, domain, mxRecords, this.options.timeout, this.log);\n    }\n\n    return result;\n  }\n\n  static isEmail(address) {\n    return address.includes('@');\n  }\n\n  static extractAddressParts(address) {\n    if (!EmailValidator.isEmail(address)) {\n      throw new Error(`\"${address}\" is not a valid email address`);\n    }\n\n    return address.split('@');\n  }\n\n  static async resolveMxRecords(domain) {\n    const records = await ninvoke(dns, 'resolveMx', domain);\n    records.sort((a, b) => a.priority > b.priority);\n    return records.map(record => record.exchange);\n  }\n\n  static async verifyMailbox(local, domain, [mxRecord], timeout, log) {\n    if (!mxRecord || /yahoo/.test(mxRecord)) {\n      log.debug('Cannot verify due to missing or unsupported MX record', mxRecord);\n      return null;\n    }\n\n    return new Promise(resolve => {\n      const socket = net.connect(25, mxRecord);\n      let resTimeout;\n\n      const ret = result => {\n        if (ret.resolved) return;\n\n        if (!socket.destroyed) {\n          socket.write('QUIT\\r\\n');\n          socket.end();\n        }\n\n        clearTimeout(resTimeout);\n        resolve(result);\n        ret.resolved = true;\n      };\n\n      const messages = [`HELO ${domain}`, `MAIL FROM: <${local}@${domain}>`, `RCPT TO: <${local}@${domain}>`];\n      socket.on('data', data => {\n        data = data.toString();\n        log.debug('Mailbox: got data', data);\n        if (isInvalidMailboxError(data)) return ret(false);\n        if (!data.includes(220) && !data.includes(250)) return ret(null);\n        if (isMultilineGreet(data)) return;\n\n        if (messages.length > 0) {\n          const message = messages.shift();\n          log.debug('Mailbox: writing message', message);\n          return socket.write(message + '\\r\\n');\n        }\n\n        ret(true);\n      });\n      socket.on('error', err => {\n        log.debug('Mailbox: error in socket', err);\n        ret(null);\n      });\n      resTimeout = setTimeout(() => {\n        log.debug(`Mailbox: timed out (${timeout} ms)`);\n        ret(null);\n      }, timeout);\n    });\n  }\n\n}\n\nmodule.exports = EmailValidator;","map":{"version":3,"sources":["C:/Users/david/react/RateCourses/client/node_modules/email-deep-validator/lib/index.js"],"names":["dns","require","net","logger","ninvoke","module","fn","args","Promise","resolve","reject","err","res","isInvalidMailboxError","smtpReply","test","isMultilineGreet","EmailValidator","constructor","options","Object","assign","timeout","verifyDomain","verifyMailbox","log","verify","address","result","wellFormed","validDomain","validMailbox","local","domain","mxRecords","extractAddressParts","debug","resolveMxRecords","length","isEmail","includes","Error","split","records","sort","a","b","priority","map","record","exchange","mxRecord","socket","connect","resTimeout","ret","resolved","destroyed","write","end","clearTimeout","messages","on","data","toString","message","shift","setTimeout","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst dns = require('dns'),\n  net = require('net'),\n  logger = require('./logger');\n\nconst ninvoke = (module, fn, ...args) => new Promise((resolve, reject) => {\n  module[fn](...args, (err, res) => {\n    if (err) return reject(err);\n    resolve(res);\n  });\n});\n\n/**\n * @see http://www.serversmtp.com/en/smtp-error\n * @param  {String} smtpReply A response from the SMTP server.\n * @return {Bool}             True if the error is recognized as a mailbox\n *                            missing error.\n */\nconst isInvalidMailboxError = smtpReply => {\n  if (\n    smtpReply &&\n    /^(510|511|513|550|551|553)/.test(smtpReply) &&\n    !/(junk|spam|openspf|spoofing|host|rbl.+blocked)/ig.test(smtpReply)\n  ) return true;\n\n  return false;\n};\n\n/**\n * @see https://www.ietf.org/mail-archive/web/ietf-smtp/current/msg06344.html\n * @param  {String}  smtpReply A message from the SMTP server.\n * @return {Boolean}           True if this is a multiline greet.\n */\nconst isMultilineGreet = smtpReply => {\n  return smtpReply && /^(250|220)-/.test(smtpReply);\n};\n\nclass EmailValidator {\n  constructor(options = { }) {\n    this.options = Object.assign({\n      timeout: 10000,\n      verifyDomain: true,\n      verifyMailbox: true\n    }, options);\n\n    this.log = options.logger || logger;\n  }\n\n  async verify(address) {\n    const result = { wellFormed: false, validDomain: null, validMailbox: null };\n    let local;\n    let domain;\n    let mxRecords;\n\n    try {\n      [local, domain] = EmailValidator.extractAddressParts(address);\n    } catch (err) {\n      this.log.debug('Failed on wellFormed check', err);\n      return result;\n    }\n\n    result.wellFormed = true;\n\n    // save a DNS call\n    if (!this.options.verifyDomain && !this.options.verifyMailbox) return result;\n\n    try {\n      mxRecords = await EmailValidator.resolveMxRecords(domain);\n      this.log.debug('Found MX records', mxRecords);\n    } catch (err) {\n      this.log.debug('Failed to resolve MX records', err);\n      mxRecords = [];\n    }\n\n    if (this.options.verifyDomain) {\n      result.validDomain = mxRecords && mxRecords.length > 0;\n    }\n\n    if (this.options.verifyMailbox) {\n      result.validMailbox = await EmailValidator.verifyMailbox(\n        local, domain, mxRecords, this.options.timeout, this.log\n      );\n    }\n\n    return result;\n  }\n\n  static isEmail(address) {\n    return address.includes('@');\n  }\n\n  static extractAddressParts(address) {\n    if (!EmailValidator.isEmail(address)) {\n      throw new Error(`\"${address}\" is not a valid email address`);\n    }\n\n    return address.split('@');\n  }\n\n  static async resolveMxRecords(domain) {\n    const records = await ninvoke(dns, 'resolveMx', domain);\n    records.sort((a, b) => a.priority > b.priority);\n    return records.map(record => record.exchange);\n  }\n\n  static async verifyMailbox(local, domain, [mxRecord], timeout, log) {\n    if (!mxRecord || /yahoo/.test(mxRecord)) {\n      log.debug('Cannot verify due to missing or unsupported MX record', mxRecord);\n      return null;\n    }\n\n    return new Promise(resolve => {\n      const socket = net.connect(25, mxRecord);\n      let resTimeout;\n\n      const ret = result => {\n        if (ret.resolved) return;\n\n        if (!socket.destroyed) {\n          socket.write('QUIT\\r\\n');\n          socket.end();\n        }\n\n        clearTimeout(resTimeout);\n        resolve(result);\n        ret.resolved = true;\n      };\n\n      const messages = [\n        `HELO ${domain}`,\n        `MAIL FROM: <${local}@${domain}>`,\n        `RCPT TO: <${local}@${domain}>`\n      ];\n\n      socket.on('data', data => {\n        data = data.toString();\n\n        log.debug('Mailbox: got data', data);\n\n        if (isInvalidMailboxError(data)) return ret(false);\n        if (!data.includes(220) && !data.includes(250)) return ret(null);\n\n        if (isMultilineGreet(data)) return;\n\n        if (messages.length > 0) {\n          const message = messages.shift();\n          log.debug('Mailbox: writing message', message);\n          return socket.write(message + '\\r\\n');\n        }\n\n        ret(true);\n      });\n\n      socket.on('error', err => {\n        log.debug('Mailbox: error in socket', err);\n        ret(null);\n      });\n\n      resTimeout = setTimeout(() => {\n        log.debug(`Mailbox: timed out (${timeout} ms)`);\n        ret(null);\n      }, timeout);\n    });\n  }\n}\n\nmodule.exports = EmailValidator;\n"]},"metadata":{},"sourceType":"script"}