{"ast":null,"code":"// swearjar\nconst swearjar = {\n  _badWords: {},\n\n  scan(text, callback) {\n    let word;\n    let key;\n    let match;\n    const notMatchedText = [];\n    let regex = /\\w+/g;\n\n    while ((match = regex.exec(text)) != null) {\n      word = match[0];\n      key = word.toLowerCase();\n\n      if (key in this._badWords.simple && Array.isArray(this._badWords.simple[key])) {\n        if (callback(word, match.index, this._badWords.simple[key], key, 'simple') === false) {\n          break;\n        }\n      } else if (key in this._badWords.emoji && Array.isArray(this._badWords.emoji[key])) {\n        if (callback(word, match.index, this._badWords.emoji[key], key, 'emoji') === false) {\n          break;\n        }\n      } else {\n        notMatchedText.push(key);\n      }\n    }\n\n    const joinedText = notMatchedText.join(' ');\n\n    for (const regexString in this._badWords.regex) {\n      regex = new RegExp(regexString, 'g');\n\n      while ((match = regex.exec(joinedText)) != null) {\n        word = match[0];\n\n        if (word) {\n          if (callback(word, match.index, this._badWords.regex[regexString], regexString, 'regex') === false) {\n            break;\n          }\n        }\n      }\n    }\n  },\n\n  profane(text) {\n    let profane = false;\n    this.scan(text, (word, index, categories) => {\n      profane = true;\n      return false; // Stop on first match\n    });\n    return profane;\n  },\n\n  scorecard(text) {\n    const scorecard = {};\n    this.scan(text, (word, index, categories) => {\n      for (let i = 0; i < categories.length; i += 1) {\n        const cat = categories[i];\n\n        if (cat in scorecard) {\n          scorecard[cat] += 1;\n        } else {\n          scorecard[cat] = 1;\n        }\n      }\n    });\n    return scorecard;\n  },\n\n  words(text) {\n    const words = {};\n    this.scan(text, (word, index, categories) => {\n      words[word] = categories;\n    });\n    return words;\n  },\n\n  censor(text) {\n    let censored = text;\n    this.scan(text, (word, index, categories) => {\n      censored = censored.substr(0, index) + word.replace(/\\S/g, '*') + censored.substr(index + word.length);\n    });\n    return censored;\n  },\n\n  detailedProfane(text) {\n    let censored = text;\n    let profane = false;\n    const words = {};\n    const categoryCount = {};\n    const wordCount = {};\n    this.scan(text, (word, index, categories) => {\n      profane = true;\n      censored = censored.substr(0, index) + word.replace(/\\S/g, '*') + censored.substr(index + word.length);\n      words[word] = categories;\n\n      for (let i = 0; i < categories.length; i += 1) {\n        const cat = categories[i];\n\n        if (cat in categoryCount) {\n          categoryCount[cat] += 1;\n        } else {\n          categoryCount[cat] = 1;\n        }\n\n        if (word in wordCount) {\n          wordCount[word] += 1;\n        } else {\n          wordCount[word] = 1;\n        }\n      }\n    });\n    return {\n      censored,\n      profane,\n      categoryCount,\n      wordCount,\n      words\n    };\n  },\n\n  setBadWords(badWords) {\n    this._badWords = badWords || {};\n  },\n\n  addRegex(word, categories) {\n    const categoryArray = Array.isArray(categories) ? categories : [categories];\n\n    if (word in this._badWords.regex) {\n      this._badWords.regex[word] = this._badWords.regex[word].concat(categoryArray);\n    } else {\n      this._badWords.regex[word] = categoryArray;\n    }\n  },\n\n  addSimple(word, categories) {\n    const categoryArray = Array.isArray(categories) ? categories : [categories];\n\n    if (word in this._badWords.simple) {\n      this._badWords.simple[word] = this._badWords.simple[word].concat(categoryArray);\n    } else {\n      this._badWords.simple[word] = categoryArray;\n    }\n  },\n\n  addEmoji(word, categories) {\n    const categoryArray = Array.isArray(categories) ? categories : [categories];\n\n    if (word in this._badWords.emoji) {\n      this._badWords.emoji[word] = this._badWords.emoji[word].concat(categoryArray);\n    } else {\n      this._badWords.emoji[word] = categoryArray;\n    }\n  }\n\n};\nswearjar._badWords = require('./config/en_US.json');\nmodule.exports = swearjar;","map":{"version":3,"sources":["C:/Users/david/react/RateCourses/client/node_modules/swearjar-extended/lib/swearjar-browser.js"],"names":["swearjar","_badWords","scan","text","callback","word","key","match","notMatchedText","regex","exec","toLowerCase","simple","Array","isArray","index","emoji","push","joinedText","join","regexString","RegExp","profane","categories","scorecard","i","length","cat","words","censor","censored","substr","replace","detailedProfane","categoryCount","wordCount","setBadWords","badWords","addRegex","categoryArray","concat","addSimple","addEmoji","require","module","exports"],"mappings":"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","sourcesContent":["// swearjar\nconst swearjar = {\n\n  _badWords: {},\n\n  scan(text, callback) {\n    let word;\n    let key;\n    let match;\n    const\n      notMatchedText = [];\n    let regex = /\\w+/g;\n\n    while ((match = regex.exec(text)) != null) {\n      word = match[0];\n      key = word.toLowerCase();\n\n      if (key in this._badWords.simple && Array.isArray(this._badWords.simple[key])) {\n        if (callback(word, match.index, this._badWords.simple[key], key, 'simple') === false) {\n          break;\n        }\n      } else if (key in this._badWords.emoji && Array.isArray(this._badWords.emoji[key])) {\n        if (callback(word, match.index, this._badWords.emoji[key], key, 'emoji') === false) {\n          break;\n        }\n      } else {\n        notMatchedText.push(key);\n      }\n    }\n\n    const joinedText = notMatchedText.join(' ');\n    for (const regexString in this._badWords.regex) {\n      regex = new RegExp(regexString, 'g');\n      while ((match = regex.exec(joinedText)) != null) {\n        word = match[0];\n\n        if (word) {\n          if (callback(word, match.index, this._badWords.regex[regexString], regexString, 'regex') === false) {\n            break;\n          }\n        }\n      }\n    }\n  },\n\n  profane(text) {\n    let profane = false;\n\n    this.scan(text, (word, index, categories) => {\n      profane = true;\n      return false; // Stop on first match\n    });\n\n    return profane;\n  },\n\n  scorecard(text) {\n    const scorecard = {};\n\n    this.scan(text, (word, index, categories) => {\n      for (let i = 0; i < categories.length; i += 1) {\n        const cat = categories[i];\n\n        if (cat in scorecard) {\n          scorecard[cat] += 1;\n        } else {\n          scorecard[cat] = 1;\n        }\n      }\n    });\n\n    return scorecard;\n  },\n\n  words(text) {\n    const words = {};\n\n    this.scan(text, (word, index, categories) => {\n      words[word] = categories;\n    });\n\n    return words;\n  },\n\n  censor(text) {\n    let censored = text;\n\n    this.scan(text, (word, index, categories) => {\n      censored = censored.substr(0, index)\n                + word.replace(/\\S/g, '*')\n                + censored.substr(index + word.length);\n    });\n\n    return censored;\n  },\n\n  detailedProfane(text) {\n    let censored = text;\n    let profane = false;\n    const words = {};\n    const categoryCount = {};\n    const wordCount = {};\n\n    this.scan(text, (word, index, categories) => {\n      profane = true;\n\n      censored = censored.substr(0, index)\n                + word.replace(/\\S/g, '*')\n                + censored.substr(index + word.length);\n      words[word] = categories;\n      for (let i = 0; i < categories.length; i += 1) {\n        const cat = categories[i];\n\n        if (cat in categoryCount) {\n          categoryCount[cat] += 1;\n        } else {\n          categoryCount[cat] = 1;\n        }\n        if (word in wordCount) {\n          wordCount[word] += 1;\n        } else {\n          wordCount[word] = 1;\n        }\n      }\n    });\n\n    return {\n      censored, profane, categoryCount, wordCount, words,\n    };\n  },\n\n  setBadWords(badWords) {\n    this._badWords = badWords || {};\n  },\n\n  addRegex(word, categories) {\n    const categoryArray = Array.isArray(categories) ? categories : [categories];\n    if (word in this._badWords.regex) {\n      this._badWords.regex[word] = this._badWords.regex[word].concat(categoryArray);\n    } else {\n      this._badWords.regex[word] = categoryArray;\n    }\n  },\n  addSimple(word, categories) {\n    const categoryArray = Array.isArray(categories) ? categories : [categories];\n    if (word in this._badWords.simple) {\n      this._badWords.simple[word] = this._badWords.simple[word].concat(categoryArray);\n    } else {\n      this._badWords.simple[word] = categoryArray;\n    }\n  },\n  addEmoji(word, categories) {\n    const categoryArray = Array.isArray(categories) ? categories : [categories];\n    if (word in this._badWords.emoji) {\n      this._badWords.emoji[word] = this._badWords.emoji[word].concat(categoryArray);\n    } else {\n      this._badWords.emoji[word] = categoryArray;\n    }\n  },\n};\n\nswearjar._badWords = require('./config/en_US.json');\n\nmodule.exports = swearjar;\n"]},"metadata":{},"sourceType":"script"}